{\rtf1\ansi\ansicpg936\cocoartf1265
{\fonttbl\f0\fnil\fcharset0 Calibri;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl276\slmult1\sa200

\f0\fs22 \cf0 1)  getFlightsByDate:\
Declaration:\
vector<Flight*>*  getFlightsByDate(string _date)\
\{\
    pair<multimap<string,Flight*>::iterator,multimap<string,Flight*>::iterator> dateRange;\
    dateRange=m_flightByDate.equal_range(_date);\
    multimap<string, Flight*>::iterator it = dateRange.first;\
    vector<Flight*>* flights = new vector<Flight*>();\
    while (it != dateRange.second) \{\
        flights->push_back(it->second);\
        ++it;\
   \}\
    return flights;\
\}\
Parameters:  Flight Date of type String, indicating like DDMMYY\
Return value: A vector of pointer pointing to Flight on that date\
Algorithm:  Specify a flight date, getFlgihtByData will a vector of pointer pointing to the flight on that specified date.  Because there are more than one flight on one day, so the the method should return multiple flights. But we one method can only return single value, so the pointers to each flight are grouped into a container\'97vector\'97as the return value. The multimap stored the data and data structure of flights. The pair<multimp<key,value>,multimap<key,value>> will return 2 iterators representing the first and last occurrences of the date on the multimap, so we got a range of flights on that date. equal_range(),which if specified method of multimap, will return 2 iterators representing the range of the value of the key ,here is the flights on the date.Using a while to go over the range ,add the flight into the vector one by one until the it reaches the last iterator. Then return a pointer pointing to a vector of pointers pointing to flight.\
}